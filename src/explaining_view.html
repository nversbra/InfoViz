<!DOCTYPE html>

<html lang="en"><head>
    <head>
        <meta charset="utf-8">
        <title>Three.js Geometry Browser</title>
        <style>
            @font-face {
                font-family: 'inconsolata';
                src: url('../resources/inconsolata.woff') format('woff');
                font-weight: normal;
                font-style: normal;
            }

            body {
                margin:0;
                font-family: 'inconsolata';
                font-size: 15px;
                line-height: 18px;
                overflow: hidden;
            }

            canvas { width: 100%; height: 100% }

            #newWindow {
                display: block;
                position: absolute;
                bottom: 0.3em;
                left: 0.5em;
                color: #fff;
            }
        </style>
        <style type="text/css"></style><style type="text/css">.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1!important}.dg.main .close-button.drag,.dg.main:hover .close-button{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;transition:opacity .1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save>ul{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height .1s ease-out;transition:height .1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid transparent}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.boolean,.dg .cr.boolean *,.dg .cr.function,.dg .cr.function *,.dg .cr.function .property-name{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco,monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px Lucida Grande,sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid hsla(0,0%,100%,.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.boolean:hover,.dg .cr.function:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}</style></head><body>



<script src="../libs/threeJS/three.min.js"></script>
<script src="../libs/DAT/DAT.gui.js"></script>
<script src="../libs/orbitControls/OrbitControls.js"></script>
<script src="../resources/ParametricGeometries.js"></script>
<script src="../libs/stats/stats.js"></script>
<script src="../resources/geometry.js"></script>

<div id="ThreeJS"></div>

<script>


var gui = new dat.GUI();
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 3000);
camera.position.z = 60;

var renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setClearColor( 0x00000, 1 );
document.body.appendChild( renderer.domElement );

var orbit = new THREE.OrbitControls( camera, renderer.domElement );
orbit.enableZoom = true;

var lights = [];
lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );
lights[ 3 ] = new THREE.DirectionalLight();

lights[ 0 ].position.set( -500, 2000, 0 );
lights[ 1 ].position.set( 1000, 2000, 1000 );
lights[ 2 ].position.set( - 1000, - 2000, - 1000 );
lights[ 3 ].position.set( 300, -400, -200 );
lights[ 3 ].intensity=0.4;

scene.add( lights[ 0 ] );
scene.add( lights[ 1 ] );
scene.add( lights[ 2 ] );
scene.add( lights[ 3 ] );


var dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(100, 100, 50);
scene.add(dirLight);

var light = new THREE.AmbientLight( 0x404040 ); // soft white light
scene.add( light );


// LIGHTS

hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
hemiLight.color.setHSL( 0.6, 1, 0.6 );
hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
hemiLight.position.set( 0, 500, 0 );
scene.add( hemiLight );

//

dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
dirLight.color.setHSL( 0.1, 1, 0.95 );
dirLight.position.set( -1, 1.75, 1 );
dirLight.position.multiplyScalar( 50 );
scene.add( dirLight );

dirLight.castShadow = false;

dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;

var d = 50;

dirLight.shadow.camera.left = -d;
dirLight.shadow.camera.right = d;
dirLight.shadow.camera.top = d;
dirLight.shadow.camera.bottom = -d;

dirLight.shadow.camera.far = 3500;
dirLight.shadow.bias = -0.0001;

var stats= new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.bottom = '0px';
stats.domElement.style.zIndex = 100;
container = document.getElementById( 'ThreeJS' );
container.appendChild( stats.domElement );


var maxDensity = 0.004; 

var data = {
        slices : 50,
        stacks : 50,
        width : 50,
        height : 50,
        translateX : 0,
        translateY : 0,
        translateZ : 0,
        phiStart : 0,
        phiLength : 6.3,
        thetaStart : 6,
        thetaLength : 6.3, 
        radius : 5,
        density : 0.0002
};


var blackHole = function (u, v) {

    rs = 0.5; 

    u = u * 10  ;
    v = v * 2 * Math.PI;
    var r =  1/4 * (4 * Math.pow(rs, 2) + Math.pow(u, 2));
    var rho;
    //if (r > rs)
    rho = Math.sqrt((r - rs) * r) + 1/2 * rs * Math.log( 2 * r  * (Math.sqrt(1 - rs/r) + 1)  - rs);
   // else
     //   rho = 0;
    var x = rho * Math.cos(v);
    var y = u - 10 ;
    var z = rho * Math.sin(v);
    return new THREE.Vector3(x, y, z);
};


var staticStar = function(u, v){
// u is radial distance to the center in the euclidian space
// v is the angle 

    //console.log(u);


    var R = data.radius;  // radius of the star 
    var rmax =  5 * R; // maximal distance plotted 
    v = v * 2 * Math.PI; // v scaled to angle range 
    var r = u * rmax;
    var R3 = Math.pow(R,3);
    var M = (4 * Math.PI / 3) * data.density * R3;

    var max_y = Math.sqrt(R3 / (2 * M)) * ( 1 - Math.sqrt(1 - 2 * M / R)) + Math.sqrt(8 * M *(rmax-2*M)) - Math.sqrt(8 * M *(R-2*M));

    var y = -max_y; 

    if (M == 0)
        y = 0;
    else {
        if (r > R){
            y += Math.sqrt(R3 / (2 * M)) * ( 1 - Math.sqrt(1 - 2 * M / R)) + Math.sqrt(8 * M *(r-2*M)) - Math.sqrt(8 * M *(R-2*M));
        } 
        else {
            y+= Math.sqrt(R3 / (2 * M)) * ( 1 - Math.sqrt(1 - 2 * M * Math.pow(r,2) / R3));
        }
    }

  
       
    var x = r * Math.cos(v);
    var z = r * Math.sin(v);
    return new THREE.Vector3(x, y, z);
}

var objects = {
    Funnel : false,
    Plane : false,
    Sphere : true, 
    Star : true
};





var BHmesh = new THREE.Object3D();
var PNmesh = new THREE.Object3D();
var SPmesh = new THREE.Object3D();
var SSmesh = new THREE.Object3D();

var wireframe;

BHmesh.add( new THREE.LineSegments(

    new THREE.Geometry(),

    new THREE.LineBasicMaterial( {
        color: 0xffffff,
        transparent: true,
        opacity: 0.5
    } )

) );

PNmesh.add( new THREE.LineSegments(

    new THREE.Geometry(),

    new THREE.LineBasicMaterial( {
        color: 0xffffff,
        transparent: true,
        opacity: 0.5
    } )

) );


/*SPmesh.add( new THREE.LineSegments(

    new THREE.Geometry(),

    new THREE.LineBasicMaterial( {
        color: 0xffffff,
        transparent: true,
        opacity: data.density * 1000
    } )

) );*/






BHmesh.add( new THREE.Mesh(

    new THREE.Geometry(),

    new THREE.MeshPhongMaterial( {
        color: 0x156289,
        emissive: 0x072534,
        side: THREE.DoubleSide,
        shading: THREE.FlatShading
    } )

) );

PNmesh.add( new THREE.Mesh(

    new THREE.Geometry(),

    new THREE.MeshPhongMaterial( {
        color: 0x156289,
        emissive: 0x072534,
        side: THREE.DoubleSide,
        shading: THREE.FlatShading
    } )

) );


/*SPmesh.add( new THREE.Mesh(

    new THREE.Geometry(),

    new THREE.MeshPhongMaterial( {
        color: 0x666666,
        opacity : data.density * 1000, 
        //side: THREE.DoubleSide,
        shading: THREE.FlatShading
    } )

) );*/

/*SSmesh.add( new THREE.Mesh(

    new THREE.Geometry(),

    new THREE.MeshPhongMaterial( {
        //color: 0x156289,
        //emissive: 0x072534,
        side: THREE.DoubleSide
        //shading: THREE.FlatShading
    } )

) );*/





function removeMesh(){


    if (objects.Funnel){
        scene.add(BHmesh);
    } else {
        scene.remove(BHmesh)
    }
    /*if (objects.Plane){
        scene.add(PNmesh);
    } else {
        scene.remove(PNmesh)
    }*/
    if (objects.Star){
        scene.add(wireframe);
    } else {
        scene.remove(wireframe)
    }

    if (objects.Sphere){
        scene.add(SPmesh);
    } else {
        scene.remove(SPmesh)
    }
}


/*var starGeometry;

var starMesh;

var wireTexture = new THREE.ImageUtils.loadTexture( 'images/square.png' );
wireTexture.wrapS = wireTexture.wrapT = THREE.RepeatWrapping; 
wireTexture.repeat.set( 40, 40 );
wireMaterial = new THREE.MeshBasicMaterial( { map: wireTexture, vertexColors: THREE.VertexColors, side:THREE.DoubleSide } );*/

var options =  function() {


    //scene.add(SSmesh);


    function generateGeometry() {

        scene.remove(wireframe);
        scene.remove(SPmesh);
        
        BH = new THREE.ParametricGeometry( blackHole, data.slices, data.stacks );
        PN=  new THREE.PlaneGeometry(data.width,data.height,data.slices,data.stacks);
        SS = new THREE.ParametricGeometry( staticStar, data.slices, data.stacks );
        SP = new THREE.SphereGeometry(data.radius, data.slices, data.stacks, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);

        material = new THREE.MeshPhongMaterial( { color: 0x000000, wireframe: false, transparent : true, opacity: 0 } );
        SPmesh = new THREE.Mesh( SP, material );
        //var color = new THREE.Color( data.density / maxDensity, data.density / maxDensity, data.density / maxDensity );
        var opacity = data.density / maxDensity + 0.1;
        console.log(opacity);
        SPmesh.material.opacity =  opacity ;

        lineMat = new THREE.LineBasicMaterial( {
            color: 0xffffff,
            transparent: false,
            opacity: 0.5, 
            polygonOffset: false
        } )

        var geo = new THREE.EdgesGeometry(SS, 0.01);
        //var geo = new THREE.WireframeGeometry(SS);

        wireframe = new THREE.LineSegments( geo, lineMat );
        //SSmesh.add(wireframe)
        //SSmesh = new THREE.Mesh( SS, wireframe );
        //scene.add(wireframe);

        /*starGeometry = new THREE.ParametricGeometry( staticStar, data.slices, data.stacks, true );
        wireMaterial.map.repeat.set( data.slices, data.stacks );

        starMesh = new THREE.Mesh( starGeometry, wireMaterial);
        scene.add(starMesh);*/



        //PN.dynamic= true;
        updateGroupGeometry( BHmesh,
            BH
            );
        /*updateGroupGeometry( PNmesh,
            PN
            );*/
        /*updateGroupGeometry( SPmesh,
            SP
            );*/
        /*updateGroupGeometry( SSmesh,
          SS
         );*/
        /*PNmesh.position.x =data.translateX;
        PNmesh.position.y = data.translateY + 5;
        PNmesh.position.z =data.translateZ;
        PNmesh.rotation.x = Math.PI / 2;
        PNmesh.rotation.z = Math.PI / 4 - 0.04;*/

        removeMesh(); // adds the meshes that are set to true from the beginning   (otherwise, they are only rendered once the controls are changed)
        


    }

    var folder = gui.addFolder( 'Controls' );

    /*var planeFolder = folder.addFolder( 'Plane Controls' );
    var sphereFolder = folder.addFolder( 'Sphere Controls' );*/
    //var starFolder = folder.addFolder('star controls');

    /*folder.add( data, 'slices', 1, 100 ).step( 1 ).onChange( generateGeometry );
    folder.add( data, 'stacks', 1, 100 ).step( 1 ).onChange( generateGeometry );
    folder.add( objects, 'Funnel').onChange( removeMesh, generateGeometry);
    folder.add( objects, 'Plane').onChange( removeMesh );
    folder.add( objects, 'Sphere').onChange( removeMesh );
    planeFolder.add( data, 'width', 1, 100 ).step( 1 ).onChange( generateGeometry );
    planeFolder.add( data, 'height', 1, 100 ).step( 1 ).onChange( generateGeometry );
    planeFolder.add( data, 'translateX', -100, 100 ).step( 1 ).onChange( generateGeometry );
    planeFolder.add( data, 'translateY', -100, 100 ).step( 1 ).onChange( generateGeometry );
    planeFolder.add( data, 'translateZ', -100, 100 ).step( 1 ).onChange( generateGeometry );

    sphereFolder.add(data,'radius',0,50).step(1).onChange(generateGeometry);
    sphereFolder.add(data,'phiStart',0,10).step(0.5).onChange(generateGeometry);
    sphereFolder.add(data,'phiLength',0,10).step(0.5).onChange(generateGeometry);
    sphereFolder.add(data,'thetaStart',0,10).step(0.5).onChange(generateGeometry);
    sphereFolder.add(data,'thetaLength',0,10).step(0.5).onChange(generateGeometry);*/

    folder.add(data, 'density', 0, maxDensity).step(0.0001).onChange(generateGeometry);


    generateGeometry();

};
options();



//scene.add(BHmesh);
//scene.add(PNmesh);



var prevFog = false;


// var data = {
//     rotationx : 0,
//     rotationy : 0
// };
// var folder = gui.addFolder( 'Rotation' );
// folder.add( data, 'rotationx', 0, 0.5 ).step( 0.001 )
// folder.add( data, 'rotationy', 0, 0.5 ).step( 0.001 )


var render = function () {

    requestAnimationFrame( render );

        stats.update();

        //SPmesh.opacity = data.density * 1000;

/*        BHmesh.rotation.x += data.rotationx;
        BHmesh.rotation.y += data.rotationy;

        PNmesh.rotation.x += data.rotationx;
        PNmesh.rotation.y += data.rotationy;

        SPmesh.rotation.x += data.rotationx;
        SPmesh.rotation.y += data.rotationy;*/


    renderer.render( scene, camera );

};

window.addEventListener( 'resize', function () {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}, false );


render();</script><div class="dg ac">

</div><canvas width="958" height="660" style="width: 958px; height: 660px;"></canvas>


</body></html>