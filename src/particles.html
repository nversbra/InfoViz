<!DOCTYPE html>

<html>

<head>
    <title>Particles</title>
    <script type="text/javascript" src="../resources/CSVtoJSONConverter/starsHMY.js"></script>
    <script type="text/javascript" src="../libs/threeJS/three.js"></script>
    <script type="text/javascript" src="../libs/orbitControls/OrbitControls.js"></script>
    <link rel="stylesheet" type="text/css" src="slider.css">





    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

<div id="zoom"><input id="setZoom" type="range" min="0" max="1" step="0.01" value="0" webkit-appearance="slider-vertical" orient="vertical" onclick="updateZoom(this.value);"></div>
    <div id="Stats-output">
    </div>
    <!-- Div which will hold the Output -->
    <div id="WebGL-output">
    </div>


    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">
        // once everything is loaded, we run our Three.js stuff.



        window.addEventListener( 'resize', onWindowResize, false );



        var controls;

        var camera, DualCamera1, DualCamera2;
        var DualActive = false;
        var Center;
        var maxDistance = 4200;
        var minDistance = 60;

        var aspect = window.innerWidth / window.innerHeight;

        var scene, webGLRenderer;
        var CurrentStage;



        function updateZoom(val) {
            var dis = camera.position.distanceTo(Center);
            var zoomLevel = Math.abs(Math.round(((maxDistance-dis)/(maxDistance-minDistance))*100)/100);
            if (zoomLevel > val){
                while(zoomLevel>val){
                    controls.dollyIn(0.95);
                    controls.update();
                    dis = camera.position.distanceTo(Center);
                    zoomLevel = Math.abs(Math.round(((maxDistance-dis)/(maxDistance-minDistance))*100)/100);
                }
            } else {
                while(zoomLevel<val){
                    controls.dollyOut(0.95);
                    controls.update();
                    dis = camera.position.distanceTo(Center);
                    zoomLevel = Math.abs(Math.round(((maxDistance-dis)/(maxDistance-minDistance))*100)/100);
                }
            }
        }


        function init() {



            //Single or split screen


            //load the csv file and parse it
            // create a scene, that will hold all our elements such as objects, cameras and lights.
            Center = new THREE.Vector3(10, -20, 0);
            scene = new THREE.Scene();
            // create a camera, which defines where we're looking at.
            camera = new THREE.PerspectiveCamera(45, aspect, 1, 5000);
            DualCamera1 = new THREE.PerspectiveCamera(45, aspect / 2, 1, 5000);
            DualCamera2 = new THREE.PerspectiveCamera(45, aspect / 2, 1, 5000);
            DualCamera1.position.x = 30;
            DualCamera1.position.y = -50;
            DualCamera1.position.z = -50;
            DualCamera2.position.x = -30;
            DualCamera2.position.y = 50;
            DualCamera2.position.z = 50;
            DualCamera1.lookAt(new THREE.Vector3(10, -20, 0));
            DualCamera2.lookAt(new THREE.Vector3(10, -20, 0));
            // create a render and set the size
            webGLRenderer = new THREE.WebGLRenderer();
            //webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            webGLRenderer.setSize(window.innerWidth, window.innerHeight);
            webGLRenderer.shadowMapEnabled = true;
            // position and point the camera to the center of the scene
            camera.position.x = -10;
            camera.position.y = 50;
            camera.position.z = 8000;
            camera.lookAt(new THREE.Vector3(10, -20, 0));
            // add the output of the renderer to the html element
            document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);
            webGLRenderer.autoClear = false;
            //controls
            controls = new THREE.OrbitControls(camera, webGLRenderer.domElement);
            controls.rotateSpeed = 1.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;
            controls.maxDistance = maxDistance;
            controls.minDistance = minDistance;
            controls.update();
            controls.dollyIn(5);
            controls.update();

            // Helpers
            // create the particle variables
            //var particleCount = 180000,
            var particles = new THREE.Geometry();
            var multiplyingFactor = 50;
            // now create the individual particles
            for (var p = 0; p < array.length; p++) {

                // create a particle with random
                star = array[p];
                // position values, -250 -> 250
                // var pX = Math.random() * 500 - 250;
                // pY = Math.random() * 500 - 250;
                // pZ = Math.random() * 500 - 250;
                particle = new THREE.Vector3(star.x * multiplyingFactor, star.y * multiplyingFactor, star.z * multiplyingFactor);

                // add it to the geometry
                particles.vertices.push(particle);
            }
            THREE.ImageUtils.crossOrigin = '';
            var pMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 20,
                map: THREE.ImageUtils.loadTexture("https://crossorigin.me/http://i.imgur.com/XVgFERU.png"),
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            // create the particle system
            var particleSystem = new THREE.Points(
                particles,
                pMaterial);


            // also update the particle system to
            // sort the particles which enables
            // the behaviour we want
            particleSystem.sortParticles = true;
            scene.add(particleSystem);

            // black hole initialization
            var blackHoleGeometry = new THREE.SphereGeometry(30, 64, 64);
            var blackHoleMaterial = new THREE.MeshBasicMaterial({color: 0x000000});
            blackHoleMaterial.side = THREE.DoubleSide;
            var blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            scene.add(blackHole);
            CurrentStage = 1;
            //AUDIO setup for the milky way scene
            //Create an AudioListener and add it to the camera
            var listener = new THREE.AudioListener();
            camera.add(listener);
            // create a global audio source
            var sound = new THREE.Audio(listener);
            var audioLoader = new THREE.AudioLoader();
            audioLoader.load('https://upload.wikimedia.org/wikipedia/commons/c/c8/Example.ogg', function (buffer) {
                sound.setBuffer(buffer);
                sound.setVolume(0.5);
                sound.play();
                sound.source.onended = function () {
                    CurrentStage++;
                    this.isPlaying = false;
                    /* sets Three wrapper property correctly */
                };
            });
            render()
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            DualCamera2.aspect = (window.innerWidth /2)/ window.innerHeight;
            DualCamera2.updateProjectionMatrix();
            webGLRenderer.setSize( window.innerWidth, window.innerHeight );
        }
            function render() {

                //start by playing the intro audio
                if (CurrentStage == 1) {
                    //Load a sound and set it as the Audio object's buffer
                    // add some rotation to the system                    
                    //particleSystem.rotation.y += 0.003;
                   // console.log(DualCamera1.zoom)
                    //console.log(DualCamera2.zoom)
                    //console.log(camera.zoom)
                }
                else if (CurrentStage == 2) {
                    //zoom in
                    if (camera.position.z > 250) {
                        camera.position.z = camera.position.z - 50;                        
                        // camera.fov *= 10;
                        // camera.updateProjectionMatrix();
                    }
                    else {
                        CurrentStage++;
                    }
                }
                var dis = camera.position.distanceTo(Center);
                var zoomLevel = Math.abs(Math.round(((maxDistance-dis)/(maxDistance-minDistance))*100)/100);

                function updateZoomSlider(){
                    document.getElementById("setZoom").value = zoomLevel
                }

                webGLRenderer.domElement.addEventListener( 'wheel', updateZoomSlider, false );


                if (zoomLevel>0.98){
                    DualActive = true;
                } else {
                    DualActive = false;
                }

                //console.log(document.getElementById("zoom"));
                // render using requestAnimationFrame
                requestAnimationFrame(render);
                if (DualActive) {
                    camera.aspect = (window.innerWidth / 2)/ window.innerHeight;
                    camera.updateProjectionMatrix();
                    webGLRenderer.setViewport(0, 0, window.innerWidth / 2, window.innerHeight);
                    webGLRenderer.render(scene, camera);
                    webGLRenderer.setViewport(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
                    webGLRenderer.render(scene, DualCamera2);
                } else {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    //console.log(controls.getAzimuthalAngle());
                    //console.log(controls.getPolarAngle());
                    //var dis = camera.position.distanceTo(Center);
                    //var zoomLevel = Math.abs(Math.round(((maxDistance-dis)/(maxDistance-minDistance))*100)/100);
                    //console.log(camera.position.distanceTo(Center));
                    //console.log(zoomLevel);

                    //console.log(camera.position.x);

                    //console.log(camera.position.y);
                    //console.log(camera.position.z);
                    webGLRenderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                    webGLRenderer.render(scene, camera);
                }


        }


        window.onload = init;
    </script>
</body>

</html>