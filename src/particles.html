<!DOCTYPE html>

<html>

<head>
    <title>Particles</title>
    <script type="text/javascript" src="../resources/CSVtoJSONConverter/starsHMY.js"></script>
    <script type="text/javascript" src="../libs/threeJS/three.js"></script>
    <script type="text/javascript" src="../libs/orbitControls/OrbitControls.js"></script>





    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div id="Stats-output">
    </div>
    <!-- Div which will hold the Output -->
    <div id="WebGL-output">
    </div>


    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">
        // once everything is loaded, we run our Three.js stuff.
        function init() {
            //Single or split screen
            var DualActive = false;

            var aspect = window.innerWidth / window.innerHeight;

            //load the csv file and parse it
            // create a scene, that will hold all our elements such as objects, cameras and lights.
            var scene = new THREE.Scene();
            // create a camera, which defines where we're looking at.
            var camera = new THREE.PerspectiveCamera(45, aspect, 1, 5000);
            var DualCamera1 = new THREE.PerspectiveCamera(45, aspect / 2, 1, 5000);
            var DualCamera2 = new THREE.PerspectiveCamera(45, aspect / 2, 1, 5000);
            DualCamera1.position.x = 30;
            DualCamera1.position.y = -50;
            DualCamera1.position.z = -50;
            DualCamera2.position.x = -30;
            DualCamera2.position.y = 50;
            DualCamera2.position.z = 50;
            DualCamera1.lookAt(new THREE.Vector3(10, -20, 0));
            DualCamera2.lookAt(new THREE.Vector3(10, -20, 0));
            // create a render and set the size
            var webGLRenderer = new THREE.WebGLRenderer();
            //webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            webGLRenderer.setSize(window.innerWidth, window.innerHeight);
            webGLRenderer.shadowMapEnabled = true;
            // position and point the camera to the center of the scene
            camera.position.x = -10;
            camera.position.y = 50;
            camera.position.z = 8000;
            camera.lookAt(new THREE.Vector3(10, -20, 0));
            // add the output of the renderer to the html element
            document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);
            webGLRenderer.autoClear = false;
            //controls
            controls = new THREE.OrbitControls(camera);
            controls.rotateSpeed = 1.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;
            // Helpers
            // create the particle variables
            //var particleCount = 180000,
            var particles = new THREE.Geometry();
            var multiplyingFactor = 50;
            // now create the individual particles
            for (var p = 0; p < array.length; p++) {

                // create a particle with random
                star = array[p];
                // position values, -250 -> 250
                // var pX = Math.random() * 500 - 250;
                // pY = Math.random() * 500 - 250;
                // pZ = Math.random() * 500 - 250;
                particle = new THREE.Vector3(star.x * multiplyingFactor, star.y * multiplyingFactor, star.z * multiplyingFactor);

                // add it to the geometry
                particles.vertices.push(particle);
            }
            THREE.ImageUtils.crossOrigin = '';
            var pMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 20,
                map: THREE.ImageUtils.loadTexture("https://crossorigin.me/http://i.imgur.com/XVgFERU.png"),
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            // create the particle system
            var particleSystem = new THREE.Points(
                particles,
                pMaterial);



            // also update the particle system to
            // sort the particles which enables
            // the behaviour we want
            particleSystem.sortParticles = true;
            scene.add(particleSystem);

            // black hole initialization
            var blackHoleGeometry = new THREE.SphereGeometry(30, 64, 64);
            var blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            blackHoleMaterial.side = THREE.DoubleSide;
            var blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            scene.add(blackHole);
            CurrentStage = 1;
            //AUDIO setup for the milky way scene
            //Create an AudioListener and add it to the camera
            var listener = new THREE.AudioListener();
            camera.add(listener);
            // create a global audio source
            var sound = new THREE.Audio(listener);
            var audioLoader = new THREE.AudioLoader();
            audioLoader.load('https://upload.wikimedia.org/wikipedia/commons/c/c8/Example.ogg', function (buffer) {
                sound.setBuffer(buffer);
                sound.setVolume(0.5);
                sound.play();
                sound.source.onended = function () {
                    CurrentStage++;
                    this.isPlaying = false; /* sets Three wrapper property correctly */
                };
            });
            function render() {

                //start by playing the intro audio
                if (CurrentStage == 1) {
                    //Load a sound and set it as the Audio object's buffer
                    // add some rotation to the system                    
                    particleSystem.rotation.y += 0.003;
                }
                else if (CurrentStage == 2) {
                    //zoom in
                    if (camera.position.z > 250) {
                        camera.position.z = camera.position.z - 50;                        
                        // camera.fov *= 10;
                        // camera.updateProjectionMatrix();
                    }
                    else {
                        CurrentStage++;
                    }
                }

                // render using requestAnimationFrame
                requestAnimationFrame(render);
                if (DualActive) {
                    webGLRenderer.setViewport(0, 0, window.innerWidth / 2, window.innerHeight);
                    webGLRenderer.render(scene, camera);
                    webGLRenderer.setViewport(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
                    webGLRenderer.render(scene, DualCamera2);
                } else {

                    webGLRenderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                    webGLRenderer.render(scene, camera);
                }
            }
            render();
        }
        window.onload = init;
    </script>
</body>

</html>