<!DOCTYPE html>

<html>

<head>
    <title>Particles</title>
    <script type="text/javascript" src="../resources/CSVtoJSONConverter/starsHMY.js"></script>
    <script type="text/javascript" src="../libs/threeJS/three.js"></script>
    <script type="text/javascript" src="../libs/orbitControls/OrbitControls.js"></script>

    <link rel="stylesheet" type="text/css" href="slider.css">





    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div style="height: 100%">
        <div style="width: 100%;height: 100%">
            <div style="float:left; width: 90%">
                <div id="WebGL-output">

                </div>

            </div>

            <div style="float:right; height: 100%">
                <input id="setZoom" type="range" min="0" max="1" step="0.01" value="0" orient="vertical" style="height: 100%" onclick="updateZoom(this.value);"
                />
            </div>

        </div>
        <div style="clear:both"></div>
        <div id="verticalLine" class="verticalLine"></div>
        <div id="Stats-output">
        </div>
        <!-- Div which will hold the Output -->

    </div>

    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">
        window.addEventListener('resize', onWindowResize, false);

        var firstScene = "Introduction";
        var secondScene = "Zoom into black hole";
        var thirdScene = "Unfold Split Screen";
        var fourthScene = "control split screen";


        var controls;

        var camera, DualCamera1, DualCamera2, cameraHelper, DualCameraHelper, particleSystem;
        var DualActive = false;
        var Center;
        var maxDistance = 4200;
        var minDistance = 60;
        var narrationEnabled = true;
        var userJump = false;

        var aspect = window.innerWidth / window.innerHeight;

        var scene, webGLRenderer;
        var CurrentStage;
        var emittedLight;
        var zoomLevel;


        function updateZoom(val) {
            var dis = camera.position.distanceTo(Center);
            var zoomLevel = Math.abs(Math.round(((maxDistance - dis) / (maxDistance - minDistance)) * 100) / 100);
            if (zoomLevel > val) {
                while (zoomLevel > val) {
                    controls.dollyIn(0.95);
                    controls.update();
                    dis = camera.position.distanceTo(Center);
                    zoomLevel = Math.abs(Math.round(((maxDistance - dis) / (maxDistance - minDistance)) * 100) / 100);
                }
            } else {
                while (zoomLevel < val) {
                    controls.dollyOut(0.95);
                    controls.update();
                    dis = camera.position.distanceTo(Center);
                    zoomLevel = Math.abs(Math.round(((maxDistance - dis) / (maxDistance - minDistance)) * 100) / 100);
                }
            }
        }


        function init() {

            //Single or split screen


            //load the csv file and parse it
            // create a scene, that will hold all our elements such as objects, cameras and lights.
            Center = new THREE.Vector3(10, -20, 0);
            scene = new THREE.Scene();
            // create a camera, which defines where we're looking at.
            camera = new THREE.PerspectiveCamera(45, aspect, 1, 5000);

            DualCamera1 = new THREE.PerspectiveCamera(45, aspect / 2, 1, 5000);
            DualCamera2 = new THREE.PerspectiveCamera(45, aspect / 2, 1, 5000);
            DualCamera1.position.x = 30;
            DualCamera1.position.y = -50;
            DualCamera1.position.z = -50;
            DualCamera2.position.x = -10;
            DualCamera2.position.y = 50;
            DualCamera2.position.z = 900;
            DualCamera1.lookAt(new THREE.Vector3(10, -20, 0));
            DualCamera2.lookAt(new THREE.Vector3(10, -20, 0));
            // create a render and set the size
            webGLRenderer = new THREE.WebGLRenderer();
            //webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            webGLRenderer.setSize(window.innerWidth, window.innerHeight);
            webGLRenderer.shadowMapEnabled = true;
            // position and point the camera to the center of the scene
            camera.position.x = -10;
            camera.position.y = 50;
            camera.position.z = 30000;
            camera.lookAt(new THREE.Vector3(10, -20, 0));
            // add the output of the renderer to the html element
            document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);
            webGLRenderer.autoClear = false;
            //controls
            controls = new THREE.OrbitControls(camera, webGLRenderer.domElement);
            controls.rotateSpeed = 1.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;
            controls.maxDistance = maxDistance;
            controls.minDistance = minDistance;
            controls.update();
            controls.dollyIn(5);
            controls.update();



            cameraHelper = new THREE.CameraViz(camera);
            DualCameraHelper = new THREE.CameraViz(DualCamera2);
            scene.add(cameraHelper);



            function updateZoomSlider() {
                console.log("updating zoom");
                document.getElementById("setZoom").value = zoomLevel
            }

            webGLRenderer.domElement.addEventListener('wheel', updateZoomSlider, false);

            // Helpers
            // create the particle variables
            //var particleCount = 180000,
            var particles = new THREE.Geometry();
            var multiplyingFactor = 50;
            // now create the individual particles
            for (var p = 0; p < array.length; p++) {
                //the star from the csv file                
                star = array[p];
                // initialize the particle with the star's information.
                particle = new THREE.Vector3(star.x * multiplyingFactor, star.y * multiplyingFactor, star.z * multiplyingFactor);
                // add it to the geometry
                particles.vertices.push(particle);
            }

            // var pMaterial = new THREE.PointsMaterial({
            //     color: 0xFFFFFF,
            //     size: 20,
            //     map: THREE.ImageUtils.loadTexture("http://localhost:8080/images/circle.png"),
            //     blending: THREE.AdditiveBlending,
            //     transparent: true
            // });
            // instantiate a loader
            var loader = new THREE.TextureLoader();

            //allow cross origin loading
            loader.crossOrigin = '';
            // load a resource
            loader.load('http://localhost:8080/images/star2.png',
                //loader.load('../images/star3.png',
                // Function when resource is loaded
                function (texture) {
                    var pMaterial = new THREE.PointsMaterial({
                        color: 0xFFFFFF,
                        size: 20,
                        map: texture,
                        alphaTest: 0.5,
                        transparent: true
                    });
                    // create the particle system
                    particleSystem = new THREE.Points(
                        particles,
                        pMaterial);
                    // also update the particle system to
                    // sort the particles |which enables
                    // the behaviour we want
                    particleSystem.sortParticles = true;
                    scene.add(particleSystem);
                }
            );




            // black hole initialization
            var blackHoleGeometry = new THREE.SphereGeometry(30, 64, 64);
            var blackHoleMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            blackHoleMaterial.side = THREE.DoubleSide;
            var blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            scene.add(blackHole);
            CurrentStage = 1;
            emitLight();
            //requestAnimationFrame(render);
            render()
        }

        function emitLight() {
            console.log("emitlight called");
            var dotGeometry = new THREE.Geometry();
            var pos = Center;
            pos.z += 30;
            dotGeometry.vertices.push(pos);
            var dotMaterial = new THREE.PointsMaterial({ size: 20, sizeAttenuation: false, color: "red" });
            emittedLight = new THREE.Points(dotGeometry, dotMaterial);
            scene.add(emittedLight);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            DualCamera2.aspect = (window.innerWidth / 2) / window.innerHeight;
            DualCamera2.updateProjectionMatrix();
            webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        }
        var listener, sound, audioLoader;
        listener = new THREE.AudioListener();
        sound = new THREE.Audio(listener);
        audioLoader = new THREE.AudioLoader();
        //function in charge of updating the animation stage when a user jumps
        function executeJumpProtocol() {
            console.log("userJump is %s", userJump)
            //notify of the user jump 
            userJump = true;
            //if a sound is playing, stop it
            if (sound.isPlaying) {

                sound.stop();
            }
        }
        // This function alters the narrative state and returns true if it did it.
        function storyLineJump(sceneName) {
            //The user will only be able to jump back and forth only in certain stages of the animation
            //we only allow a user to go to the first stage if the stage 3 has been completed
            if (sceneName === firstScene) {
                if (CurrentStage !== 3 &&CurrentStage !== 6) {
                    executeJumpProtocol();
                }
                camera.position.x = -10;
                camera.position.y = 50;
                camera.position.z = 30000;
                camera.lookAt(new THREE.Vector3(10, -20, 0));
                CurrentStage = 1;
                controls.update();
                return true
            }
            else if (sceneName === secondScene) {
                console.log("jumping back to second scene");
                if (CurrentStage !== 3 &&CurrentStage !== 6)  {
                    executeJumpProtocol();
                }
                camera.position.x = -0.2799995955564319;
                camera.position.y = 1.3999979777821712;
                camera.position.z = 389.99878666929555;
                camera.lookAt(new THREE.Vector3(10, -20, 0));
                CurrentStage = 4;
                controls.update();

                return true
            }
            else {

                return false;
            }
        }


        function render(sceneName) {

            if (typeof (sceneName) === "string") {
                //hannah's library invokes the render method with a parameter which apparently exists as an override in threejs
                //therefore in case this method was called by clicking it must be ignored so the rendering process isnt overdone.                
                storyLineJump(sceneName);
                return null;
            }



            if (narrationEnabled) {
                narrate();
            }
            var dis = camera.position.distanceTo(Center);
            zoomLevel = Math.abs(Math.round(((maxDistance - dis) / (maxDistance - minDistance)) * 100) / 100);



            function showVertLine(s) {
                if (s) { document.getElementById("verticalLine").style.visibility = "visible"; }
                else { document.getElementById("verticalLine").style.visibility = "hidden"; }
            }





            ////if (emittedLight!=undefined){
            //    console.log("There is a light")
            //    if (emittedLight.position.distanceTo(DualCamera2) > 2) {
            //        emittedLight.translateOnAxis(DualCamera2.position, 5);
            //    } else {
            //        scene.remove(emittedLight);
            //        emittedLight=null;
            //    }
            //}





            emittedLight.material.color.set(new THREE.Color(zoomLevel, Math.abs(1 - zoomLevel), zoomLevel));

            if (zoomLevel > 0.95) {
                DualActive = true;
            } else {
                DualActive = false;
            }
            showVertLine(DualActive);


            // render using requestAnimationFrame
            requestAnimationFrame(render);
            if (DualActive) {
                scene.add(DualCameraHelper);
                scene.add(cameraHelper);
                camera.aspect = (window.innerWidth / 2) / window.innerHeight;
                camera.updateProjectionMatrix();
                webGLRenderer.setViewport(0, 0, window.innerWidth / 2, window.innerHeight);
                webGLRenderer.render(scene, camera);
                webGLRenderer.setViewport(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
                emittedLight.material.color.set(new THREE.Color(0, 1, 0));
                webGLRenderer.render(scene, DualCamera2);
            } else {
                try {
                    scene.remove(cameraHelper);
                    scene.remove(DualCameraHelper);
                } catch (e) { }
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                webGLRenderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                webGLRenderer.render(scene, camera);
            }
        }


        function narrate() {
            //this function 
            function incStage() {
                console.log("IncStage called with jump");
                console.log(userJump);
                console.log("and currentStage");
                console.log(CurrentStage);
                if (!userJump) {
                    //only increase the stage if the user has not changed the stage
                    CurrentStage++;
                }
                else {
                    //do nothing and restore the userJump switch
                    userJump = false;
                }


            }



            //start by playing the intro audio
            if (CurrentStage == 1) {
                //disable controls rotation and zoom so we guide the user through the milky way
                controls.enableRotate = false;
                controls.enableZoom = false;
                camera.add(listener);
                //restart the object references so that the global reference allows us to stop the sound whenever we want
                listener = new THREE.AudioListener();
                sound = new THREE.Audio(listener);
                audioLoader = new THREE.AudioLoader();
                audioLoader.load('https://upload.wikimedia.org/wikipedia/commons/c/c8/Example.ogg', function (buffer) {
                    sound.setBuffer(buffer);
                    sound.setVolume(0.5);
                    sound.play();
                    sound.source.onended = function () {
                        console.log("onended called")
                        this.isPlaying = false;
                        incStage();
                    };
                });
                CurrentStage++;

            }
            // Rotate the camera while the narrator explains what the milky way is.
            else if (CurrentStage == 2) {
                if (particleSystem) {
                    particleSystem.rotation.y += 0.003;
                }

            }
            // Zoom into the black hole so that the explaining audio can play
            else if (CurrentStage == 3) {
                //zoom in
                if (camera.position.z > 390) {
                    camera.position.z = camera.position.z - 30;
                    // camera.fov *= 10;
                    // camera.updateProjectionMatrix();
                }
                else {
                    CurrentStage++;
                }
            }
            // play the audio explaining the black hole
            else if (CurrentStage == 4) {
                console.log(camera);
                //restart the object references so that the global reference allows us to stop the sound whenever we want
                listener = new THREE.AudioListener();
                sound = new THREE.Audio(listener);
                audioLoader = new THREE.AudioLoader();
                audioLoader.load('http://localhost:8080/resources/audios/Vocaroo_s1yHMFtKBipb.ogg', function (buffer) {
                    sound.setBuffer(buffer);
                    sound.setVolume(0.5);
                    sound.play();
                    sound.source.onended = function () {
                        incStage();
                        this.isPlaying = false;
                        /* sets Three wrapper property correctly */
                    };
                });
                CurrentStage++;
            }
            //rotate the camera while a black hole is explained
            else if (CurrentStage == 5) {
                particleSystem.rotation.y += 0.003;
            }
            // once the audio explaining a blackholes is done, zoom in to activate the next view
            else if (CurrentStage == 6) {
                if (camera.position.z > 100) {
                    camera.position.z = camera.position.z - 1;
                    // camera.fov *= 10;
                    // camera.updateProjectionMatrix();
                }
                else {
                    CurrentStage++;
                    //window.location = "http://www.google.com";
                }
            }
        }

        window.onload = init;
    </script>
    <div>
        <!--<p id="narration"> </p>-->
        <p onclick="forward()" id="next_round">&#8250;</p>
        <div id="storyline" style="position:absolute; width:1000px;height: 150px; color: white; left:50%;
        margin-left:-300px; bottom:0px;"></div>
    </div>
    <script type="text/javascript">
        var storyLineData = [
            { "value": 1, "name": firstScene, "radius": "18", img: '../images/noise-background.jpeg' },
            { "value": 5, "name": secondScene, img: '../images/noise-background.jpeg' },
            { "value": 7, "name": thirdScene, "radius": "18", img: '../images/noise-background.jpeg' },
            { "value": 8, "name": fourthScene, img: '../images/ noise-background.jpeg', color: "#777", background: "#777" }
        ];

        var narrationPhases = ["initEView", "2D", "flatPath", "addStar", "massInteraction", "collapse", "fadeOut", "compareLength"];
    </script>
    <script src="../resources/d3.v2.min.js" type="application/javascript"></script>
    <script src="../resources/storyLine.js" type="application/javascript"></script>
    <script type="text/javascript">
        StoryLine.draw("#storyline", storyLineData, { dateDimension: false, color: "#FFF", showLabels: true });
    </script>
</body>

</html>